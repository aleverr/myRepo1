package it.cogeaps.web.rest.security;

import it.cogeaps.web.rest.controller.ExceptionAwareController;
import it.cogeaps.web.rest.exception.OperationNotPermittedException;
import it.omitech.cogeaps.model.Profilo;
import it.omitech.cogeaps.model.SpidAccessToken;
import it.omitech.cogeaps.model.Utente;
import it.omitech.cogeaps.service.AuthenticationService;
import it.omitech.cogeaps.service.SpidAccessTokenService;
import it.omitech.cogeaps.service.UtenteService;
import org.acegisecurity.Authentication;
import org.acegisecurity.providers.UsernamePasswordAuthenticationToken;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import java.io.IOException;
import java.util.Date;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;

@Controller
@RequestMapping("/auth")
public class SecurityController extends ExceptionAwareController {

    private final ITokenEncoder tokenEncoder;
    private final ITokenRefresher tokenRefresher;
    private final UtenteService utenteService;
    private final AuthenticationService authenticationService;
    private final boolean cookieSecured;

	@Autowired
	private SpidAccessTokenService spidAccessTokenService;

    @Autowired
    public SecurityController(final ITokenEncoder tokenEncoder,
                              final ITokenRefresher tokenRefresher,
                              final UtenteService utenteService,
                              final AuthenticationService authenticationService,
                              @Value("${jwt.cookie.secured:false}") final boolean cookieSecured) {
        this.tokenEncoder = tokenEncoder;
        this.tokenRefresher = tokenRefresher;
        this.utenteService = utenteService;
        this.authenticationService = authenticationService;
        this.cookieSecured = cookieSecured;
    }

    @ResponseBody
    @RequestMapping(value = "/login", method = RequestMethod.POST, produces = "application/json")
    public JwtTokenDto login(@RequestBody JwtTokenGenerationRequestDto requestDto, HttpServletRequestWrapper request, HttpServletResponse response) {
 
    	// ---------------------- controllo se è un accesso SPID ---------------------------------------
    	if (requestDto.getUsername().equals("idSpid_JN5PYA0bL")) {
    		SpidAccessToken spidAccessToken = spidAccessTokenService.getIdSpidAccessToken(requestDto.getPassword());

    		if (spidAccessToken != null) {   			
    			// controllo diff tempo che non sia maggiore di 10 sec
				Date date = new Date();
				long datemilli = date.getTime();
				long dataUltimoAccesso = spidAccessToken.getDataUltimoAccesso().getTime();
				long diff = datemilli - dataUltimoAccesso;
          		 
          		 if (diff <= 10000) {
	    	        JwtTokenDto jwtTokenDto;
	    	        try {
	    	            jwtTokenDto = generateJwtTokens(spidAccessToken.getProfessionistaCodiceFiscale(), response);
	    	        } catch (TokenGenerationException e) {
	    	            throw new InvalidGenerationRequestException("It was not possible to generate token", e);
	    	        }
	    	        jwtTokenDto.setRefreshToken(spidAccessToken.getRefreshToken());
	    	        jwtTokenDto.setToken(spidAccessToken.getToken());
	    	        
	    	        return jwtTokenDto;
	    		}
          		 UsernamePasswordAuthenticationToken usernamePasswordAuth = new UsernamePasswordAuthenticationToken(requestDto.getUsername(), requestDto.getPassword());
          		 Authentication authentication;
                 try {
                     authentication = authenticationService.authenticate(usernamePasswordAuth);
                 } catch (Throwable e) {
                     throw new OperationNotPermittedException("Login failed");
                 }

         		 //return null;
     		 }
    	}
    	// ---------------------------------------------------------------------------------------------
    	
    	if (!validLoginRequest(requestDto)) {
            throw new InvalidGenerationRequestException("The token generation request is missing mandatory attributes");
        }

        UsernamePasswordAuthenticationToken usernamePasswordAuth = new UsernamePasswordAuthenticationToken(requestDto.getUsername(), requestDto.getPassword());

        Authentication authentication;

        try {
            authentication = authenticationService.authenticate(usernamePasswordAuth);
        } catch (Throwable e) {
            throw new OperationNotPermittedException("Login failed");
        }

        if (!authentication.isAuthenticated()) {
            throw new OperationNotPermittedException("Login failed");
        }

        Utente principal = (Utente) authentication.getPrincipal();

        // questa login Ã¨ resa disponibile solo per professionisti
        if (principal == null || principal.getRoles() == null || principal.getRoles().isEmpty() || !principal.getRoles().contains(Profilo.RoleEnum.ROLE_PROFESSIONISTA)) {
            invalidateCookies(response);
            throw new OperationNotPermittedException("Login failed");
        }

        JwtTokenDto jwtTokenDto;

        try {
            jwtTokenDto = generateJwtTokens(requestDto.getUsername(), response);
        } catch (TokenGenerationException e) {
            throw new InvalidGenerationRequestException("It was not possible to generate token", e);
        }

        return jwtTokenDto;
    }

    
    
    @RequestMapping(value = "/logout", method = RequestMethod.POST, produces = "application/json")
    public void logout(HttpServletResponse response) {

        invalidateCookies(response);
    }

    /*
     * TODO: add some checks to ensure spid auth validation
     */
    @ResponseBody
    @RequestMapping(value = "/token", method = RequestMethod.POST, produces = "application/json")
    public JwtTokenDto token(@RequestBody JwtTokenGenerationRequestDto requestDto, HttpServletRequestWrapper request, HttpServletResponse response) {

        if (!validTokenRequest(requestDto)) {
            throw new InvalidGenerationRequestException("The token generation request is missing mandatory attributes");
        }

        Utente utente = utenteService.getWithoutRestrictions(requestDto.getUsername());

        if (utente == null) {
            throw new InvalidGenerationRequestException("Invalid token generation request");
        }

        JwtTokenDto jwtTokenDto;

        try {
            jwtTokenDto = generateJwtTokens(requestDto.getUsername(), response);
        } catch (TokenGenerationException e) {
            throw new InvalidGenerationRequestException("It was not possible to generate token", e);
        }

        return jwtTokenDto;
    }

    @ResponseBody
    @RequestMapping(value = "/token/refresh", method = RequestMethod.POST, produces = "application/json")
    public JwtTokenDto token(@RequestBody JwtTokenRefreshRequestDto requestDto, HttpServletResponse response) {

        if (!validRefreshRequest(requestDto)) {
            throw new InvalidGenerationRequestException("The token generation request is missing mandatory attributes");
        }

        JwtTokenDto jwtTokenDto;

        try {
            jwtTokenDto = tokenRefresher.refresh(requestDto.getToken(), requestDto.getRefreshToken());
        } catch (TokenRefreshException e) {
            throw new InvalidRefreshRequestException(e.getMessage(), e);
        }

        applyTokensToResponse(jwtTokenDto, response);

        return jwtTokenDto;
    }

    private boolean validTokenRequest(JwtTokenGenerationRequestDto requestDto) {
        return requestDto.getUsername() != null && !requestDto.getUsername().isEmpty();
    }

    private boolean validLoginRequest(JwtTokenGenerationRequestDto requestDto) {
        return (requestDto.getUsername() != null && !requestDto.getUsername().isEmpty()) && (requestDto.getPassword() != null && !requestDto.getPassword().isEmpty());
    }

    private boolean validRefreshRequest(JwtTokenRefreshRequestDto requestDto) {
        return (requestDto.getToken() != null && !requestDto.getToken().isEmpty()) && (requestDto.getRefreshToken() != null && !requestDto.getRefreshToken().isEmpty());
    }

    private JwtTokenDto generateJwtTokens(final String username, HttpServletResponse response) throws TokenGenerationException {

        JwtTokenDto tokenDto = tokenEncoder.encode(username);

        applyTokensToResponse(tokenDto, response);

        return tokenDto;
    }

    private void applyTokensToResponse(JwtTokenDto tokenDto, HttpServletResponse response) {

        Cookie tokenCookie = new Cookie(SecurityConsts.TOKEN_KEY, tokenDto.getToken());
        tokenCookie.setPath("/");
        tokenCookie.setHttpOnly(true);
        tokenCookie.setSecure(cookieSecured);
        response.addCookie(tokenCookie);

        Cookie refreshTokenCookie = new Cookie(SecurityConsts.REFRESH_TOKEN_KEY, tokenDto.getRefreshToken());
        refreshTokenCookie.setPath("/");
        refreshTokenCookie.setHttpOnly(true);
        refreshTokenCookie.setSecure(cookieSecured);
        response.addCookie(refreshTokenCookie);

        Cookie jsessionCookie = new Cookie("JSESSIONID", "");
        jsessionCookie.setPath("/Cogeaps");
        jsessionCookie.setHttpOnly(true);
        jsessionCookie.setSecure(cookieSecured);
        jsessionCookie.setMaxAge(0);
        response.addCookie(jsessionCookie);
    }

    private void invalidateCookies(HttpServletResponse response) {

        Cookie tokenCookie = new Cookie(SecurityConsts.TOKEN_KEY, "");
        tokenCookie.setPath("/");
        tokenCookie.setHttpOnly(true);
        tokenCookie.setMaxAge(0); // expired
        response.addCookie(tokenCookie);

        Cookie refreshTokenCookie = new Cookie(SecurityConsts.REFRESH_TOKEN_KEY, "");
        refreshTokenCookie.setPath("/");
        refreshTokenCookie.setHttpOnly(true);
        refreshTokenCookie.setMaxAge(0); // expired
        response.addCookie(refreshTokenCookie);
    }
}
